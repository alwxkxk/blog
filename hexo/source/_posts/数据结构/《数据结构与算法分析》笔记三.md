---
title: 《数据结构与算法分析》笔记三
toc: true
abbrlink: 17422
date: 2019-06-18 19:50:06
tags:
  - 数据结构与算法
  - C
hidden: true
---

&emsp;[《数据结构与算法分析——C语言描述》](https://book.douban.com/subject/1139426/)，第四章的学习笔记，讨论的是树型的数据结构。同时有部分笔记来自于《离散数学及其应用》里第七章 树。在《离散数学及其应用》里先讨论图再讨论树，而在《数据结构与算法分析——C语言描述》是先讨论树，后面再讨论图。
&emsp;之前讨论的列表型结构，如同一维直线，操作的时间复杂度与其长度相关，典型值为`O(N)`。而现在讨论的树型结构，如同二维平面，操作的时间复杂度与其深度相关，典型值为`O(logN)`。

## 树（Tree）
<img alt="树" src="/blog_images/tree.jpg" style="width:40%;">
&emsp;树是没有简单回路的连通无向图，即每对顶点只存在唯一的简单通路。可以将任意一点作为根（root），每条边的方向都指向离开根。
&emsp;拥有相同父母顶点(parent)的顶点被称为兄弟（siblings），没有子节点的顶点称为叶（leaves），有子节点的顶点称为内点（interior node）。节点的深度（depth）指根到节点所经过的节点数（根的深度为0）。节点的高度（height）指节点到最深叶的节点数（叶的高度为0）。
&emsp;若树中的每个内点都拥有不超过m个子节点，则此树为m元树。若每个内点都恰好有m个子节点，则称为正则m元树。数据结构一书中，把2元树 称为 二叉树（Binary Tree）。
&emsp;拥有N个节点的树，必然拥有N-1条边。高度为n的m元树里至多有mⁿ个叶子。（高度为n的2元树最多拥有2ⁿ个叶子，对数运算可得：拥有N个叶子的2元树中，此树的最小高度为logN）在一棵高度为h的m元树的所有叶子都在h层或h-1层，则这棵树是平衡的。

### 结构体定义
&emsp;在定义结构体时，并不会把所有子节点的信息都保存到结构体里，如同链表中只提供了指向下一个，树中只提供了指向第一个子节点（纵向走）与指向兄弟节点的功能（横向走）。
```c
struct TreeNode{
  ElementType Element;
  PtrToNode FirstChild;
  PtrToNode NextSibling;
}
```

<img alt="树" src="/blog_images/tree.png" style="width:40%;">
&emsp;对于程序来说，树的结构是这样的：
<img alt="树2" src="/blog_images/tree2.png" style="width:40%;">

### 二叉搜索树（Binary Search Tree : BST）
&emsp;所有节点的子节点数不超过2的树称为二叉树（Binary Tree）。
&emsp;在二叉树的基础上，再添加限制条件：对任意节点X，X的左子树的所有值都比X小，所有右子树的值都比X大，此称为二叉搜索树。
&emsp;二叉搜索树使得所有节点都处于一种“半排序”的状态中，这种状态使得进行对比操作时更快。相对应地，插入与删除节点时有可能需要移动其它节点以保持满足限制条件。
&emsp;然而，当出现一组大量升序（或降序）的数值组逐一插入到二叉搜索树中时，二叉搜索树的右子树（或左子树）不断加深，导致整棵树右深（左深）。不平衡的树拥有太大的深度导致性能下降。除非保证输入的随机性，否则二叉搜索树的性能会随着时间而不断降低。

### AVL树（Adeson-Velskii and Landis Tree）
&emsp;为了保证二叉搜索树处于一种“相对平衡”的状态，在此之上再添加限制条件：对于任意节点X，X的左子树与右子树的最大高度相差不超过1。相对应的，在插入删除节点时，需要做更多的操作以保证满足限制条件。
<img alt="AVL树" src="/blog_images/AVL-tree.png" style="width:40%;">
&emsp;注意，此时树还不是平衡（并不是所有叶子在最后两层）。

### 伸展树（Splay Tree）
&emsp;在实际使用时发现，二叉树中O(N)这种最坏情况操作并不频繁出现，而且应用程序往往更倾向于访问最近已经访问过的数据。伸展树就是针对最新被访问节点进行优化的树，对被访问的节点进行类似于AVL树的旋转操作，使得最近被访问节点更靠前。

### B树（B-Tree）
&emsp;B树满足以下条件：
- 根节点拥有0 或 2至M个子节点。
- 所有内点都拥有`[M/2]`到`M`个子节点。
- 所有叶都在同一深度。
<img alt="B树" src="/blog_images/B-tree.png" style="width:40%;">
&emsp;B树往往只有几层深度，常用于数据库系统，磁盘操作等。


## 相关补充 
&emsp;来源于《离散数学及其应用》
### 运用树的例子
- 决策树
假定有重量相同的7枚硬币和重量较轻的1枚伪币，使用1架天平找到这8枚币中的伪币。天平称重有三种可能：等重、左轻、右轻。三种可能对应着3元树，8枚币对应8种可能性即有8个叶子，决策树的高度至少是[log₃8 = 2]，即至少称两次重。

- 前缀码
使用位串代表字母，例如把e编码成0，a编码成10，t编码成11，则10110代表ate的编码。

- 赫夫曼编码
数据压缩中的基本算法，根据字符串中字母的出现频率，出现频率高的字母使用位数更少的数来代表它。使用贪心算法导出了重优编码树。

- 最小生成树
对带权图（两点之间的线带有权重值）生成 一棵权重和最小的树。

### 树的遍历
<img alt="树的遍历方向" src="/blog_images/list-traversal.jpg" style="width:40%;">
&emsp;遍历方式是针对根的访问次序，其方向全都是逆时针。

- 前序遍历（先访问根）
带根的树，先访问根，左子树再进行前序遍历，然后再右子树进行前序遍历。
- 中序遍历（第二个访问根）
带根的树，先以中序遍历第一个子节点，再访问根，然后再以中序遍历剩下的子节点。
- 后序遍历（最后才访问根）
带根的树，先以后序遍历所有子节点，再访问根。



### 生成树的方法
![](/blog_images/generate-tree.jpg)

- 深度优先搜索
任意选一点，不断向下走，直到无法继续时回退再走另一条路。
- 宽度优先搜索
任意选一点，将直接相连的作为子节点。







