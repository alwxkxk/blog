---
title: 《数据结构与算法分析》笔记一
toc: true
abbrlink: 17102
date: 2019-06-15 16:16:53
tags:
- 数据结构与算法
- C
hidden: true
---

&emsp;[《数据结构与算法分析——C语言描述》](https://book.douban.com/subject/1139426/)，第一二章的学习笔记，主要讨论时间复杂度与算法分析的方法。

## 时间复杂度
&emsp;我们日常编写一段代码以解决一个特定问题时，为了判断这段代码效率（或称性能）是否足够快，我们设定每一步代码执行所需要时间为一个时间单元，简单举例：
```c
int a=1;
int b=2;
int c=a+b;
```

&emsp;在上面代码中，简单地声明了两个变量并相加得到另一个变量，共三步。所以我们就判断这一代码片段所需要时间为3个时间单元（后面省略时间单元，如简称为3）。当然，这并不是准确的具体的物理时间（比如说几秒钟），其真正的物理时间取决于硬件的性能，编译后的指令等等诸多因素。在对比代码A与代码B的快慢时，我们无需知道准确的物理时间，我们只需要明白时间单元为10的代码会比100的代码更快就可以了，最终目的是比较出谁更快即可。如果代码A需要N个时间单元，我们就说这段代码时间复杂度为N。

```c
function(n){
  int i=1;
  int result =0;
  while(i<n){
    result += i;
    i++;
  }
}
```

&emsp;上面代码中，假设传入n为3，代码实际执行步骤为：2,3,4,5,6,4,5,6 ，共执行了9步。当n为N时，共执行`2+(N-1)*3+1 = 3N`，即这代码的时间复杂度为3N。

```c
for(i=0;i<n;i++)
  for(j=0;j<n;j++)
    k++;
```
&emsp;上面代码中两个循环，n为N时，其时间复杂度为`N*N=N²`。
&emsp;除了时间复杂度，还有空间复杂度，指此算法所用的空间多少，一般来说时间复杂度与空间复杂度不可兼得。时间复杂度低的算法往往需要大量空间，能节约空间的算法往往是以时间作为代价，故有“时间换空间，空间换时间”的说法。

## 算法分析
&emsp;算法就是针对特定问题的解决方案（或说解题思路）。每个问题当然拥有多种解决方案（即多种算法），这几种算法转换成代码后，当然拥有不同的时间复杂度，时间复杂度最低的便是这个问题的最佳算法。
&emsp;假设两个函数`f(n)`与`g(n)`，`f(n)`的时间复杂度为`1000N`而`g(n)`的时间复杂度为`N²`。当N取小值时（小于1000），明显`1000N`比`N²`的值更大，但是 __在实际使用时N往往是一个极大值,毕竟只有需要大量计算的地方才会思考如何使用更好的算法__ ，而计算量小的地方优化的意义并不大。当N取极大值，比如说N取100万，或1千万，明显是`N²`比`1000N`更大。__比较两个算法哪个更优秀，默认比的是N取极大值的时哪个所需时间越少，即我们比较的是增长率，增长率越低的算法在后期的所需时间越少__，所以这里我们判断`f(n)`的时间复杂度比`g(n)`更低。
&emsp;同样的，__由于N取的是极大值，在计算时间复杂度时，我们往往可以忽略小值__，比如时间复杂度为`N+1`往往写成`N`,`3N`也往往写成`N`，而`N²+N`则可写成`N²`。（学过高数的读者应该都知道高数经常用到 忽略小值 这个技巧。）
&emsp;典型的时间复杂度从低到高排列如下：

时间复杂度|说明|备注
---|---|---
C|constant|常数
Log N|logarithmic|对数
Log² N|log-squared|
N|linear|线性
NLog N| | 
N²|quadratic|平方
N³|cubic|立方
2ⁿ|exponential|指数

&emsp;验证自己所计算的时间复杂度是否正确，可通过传入N不同值，看执行所需时间是否符合 线性/指数（与时间复杂度大约相符的增长率） 等方式增长。




